<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Isometric Grid with NPCs</title>
  <style>
    /* Basic reset */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* Center everything in the viewport */
    body {
      font-family: Arial, sans-serif;
      background-color: #f4f4f4;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      color: #333;
    }

    header {
      margin-bottom: 20px;
      text-align: center;
    }

    header h1 {
      font-size: 2em;
      color: #32CD32; /* Lime green */
    }

    #controls {
      display: flex;
      align-items: center;
      margin-bottom: 20px;
    }

    #controls input[type="color"] {
      margin-right: 20px;
      padding: 5px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    /* The parent container for isometric transform */
    .grid-container {
      position: relative;
      transform: rotateX(60deg) rotateZ(45deg);
      transform-origin: center center;
      transform-style: preserve-3d;
    }

    #contenedor {
      position: relative;
      background-color: #ccc;
    }

    /* Each cell is just a float-based square. */
    .celda {
      width: 10px;
      height: 10px;
      background-color: #fff;
      border-left: 1px solid #ddd;
      border-bottom: 1px solid #ddd;
      transition: background 0.3s;
      cursor: pointer;
      float: left;
      position: relative; /* for NPC circles */
    }

    .celda:hover {
      background: rgba(255, 0, 0, 0.1);
    }

    /* NPC circle */
    .npc {
      width: 10px;
      height: 10px;
      background-color: blue;
      border-radius: 50%;
      position: absolute;
      top: 0;   /* If you want to center within cell, adjust top/left. */
      left: 0;
      z-index: 99;
    }

    /* Navigation Buttons */
    .nav-button {
      position: absolute;
      background-color: #32CD32; /* Lime green */
      border: none;
      color: white;
      padding: 10px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.2em;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: background 0.3s, transform 0.2s;
      z-index: 999;
    }

    .nav-button:hover {
      background-color: #28a428;
      transform: scale(1.1);
    }

    /* Position of arrow buttons inside .grid-container so they rotate too */
    #arriba {
      top: -50px;
      left: 50%;
      transform: translateX(-50%);
    }
    #abajo {
      bottom: -50px;
      left: 50%;
      transform: translateX(-50%);
    }
    #izquierda {
      left: -50px;
      top: 50%;
      transform: translateY(-50%);
    }
    #derecha {
      right: -50px;
      top: 50%;
      transform: translateY(-50%);
    }

    /* Responsive (optional) */
    @media (max-width: 600px) {
      .nav-button {
        padding: 8px;
        font-size: 1em;
      }
      header h1 {
        font-size: 1.5em;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Isometric Grid with NPCs</h1>
    <div id="controls">
      <input type="color" id="color" value="#ff0000" title="Choose Cell Color">
    </div>
  </header>

  <div class="grid-container">
    <button id="arriba" class="nav-button" title="Move Up">⬆️</button>
    <button id="abajo" class="nav-button" title="Move Down">⬇️</button>
    <button id="izquierda" class="nav-button" title="Move Left">⬅️</button>
    <button id="derecha" class="nav-button" title="Move Right">➡️</button>
    <div id="contenedor"></div>
  </div>

  <script>
    let desfasex = 0;
    let desfasey = 0;
    let color = "#ff0000"; // Default color
    const anchura = 20;    // how many cells wide
    const altura = 20;     // how many cells tall
    const tamanio = 40;    // pixel size per cell

    // User color selection
    document.querySelector("#color").onchange = function(){
      color = this.value;
    };

    const contenedor = document.querySelector("#contenedor");

    function dibuja(){
      contenedor.innerHTML = "";
      contenedor.style.width = (anchura * tamanio) + "px";
      contenedor.style.height = (altura * tamanio) + "px";

      for(let x = desfasex; x < anchura + desfasex; x++){
        for(let y = desfasey; y < altura + desfasey; y++){
          const celda = document.createElement("div");
          celda.classList.add("celda");
          celda.style.width = tamanio + "px";
          celda.style.height = tamanio + "px";
          celda.setAttribute("data-x", x);
          celda.setAttribute("data-y", y);

          // Clicking a cell -> paint color & save to server
          celda.onclick = function(){
            this.style.background = color;
            const payload = {
              color: color,
              x: x,
              y: y
            };
            fetch("http://localhost:3000/save-cell", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload)
            })
            .then(r => r.json())
            .then(resp => {
              // update done (resp.status === 'ok')
            })
            .catch(err => console.error(err));
          };
          contenedor.appendChild(celda);
        }
      }
    }

    dibuja();

    // Periodic updates: every 1s, fetch new data
    let timer = setTimeout(bucle, 1000);

    function bucle() {
      // 1) Fetch painted cells
      fetch("http://localhost:3000/celdas")
        .then(response => response.json())
        .then(datos => {
          datos.forEach(dato => {
            const selector = `.celda[data-x='${dato.x}'][data-y='${dato.y}']`;
            const foundCell = document.querySelector(selector);
            if (foundCell) {
              foundCell.style.background = dato.color;
            }
          });
        })
        .catch(err => console.error("Cell fetch error:", err));

      // 2) Fetch NPCs
      fetch("http://localhost:3000/npcs")
        .then(response => response.json())
        .then(npcs => {
          // Remove old NPC markers
          document.querySelectorAll(".npc").forEach(n => n.remove());

          // Place new NPCs
          npcs.forEach(npc => {
            const selector = `.celda[data-x='${npc.x}'][data-y='${npc.y}']`;
            const foundCell = document.querySelector(selector);
            if (foundCell) {
              const npcDiv = document.createElement("div");
              npcDiv.classList.add("npc");
              npcDiv.setAttribute("data-id", npc.id);
              foundCell.appendChild(npcDiv);
            }
          });
        })
        .catch(err => console.error("NPC fetch error:", err));

      clearTimeout(timer);
      timer = setTimeout(bucle, 1000);
    }

    // Navigation: shift the grid window
    document.querySelector("#arriba").onclick = function(){
      desfasex--;
      dibuja();
    };
    document.querySelector("#abajo").onclick = function(){
      desfasex++;
      dibuja();
    };
    document.querySelector("#izquierda").onclick = function(){
      desfasey--;
      dibuja();
    };
    document.querySelector("#derecha").onclick = function(){
      desfasey++;
      dibuja();
    };
  </script>
</body>
</html>

